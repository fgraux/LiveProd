/// <reference types="node" />
import { EventEmitter } from 'events';
import { XKeys } from '@xkeys-lib/core';
export interface XKeysWatcherEvents {
    connected: (xkeysPanel: XKeys) => void;
    error: (err: any) => void;
}
export declare interface XKeysWatcher {
    on<U extends keyof XKeysWatcherEvents>(event: U, listener: XKeysWatcherEvents[U]): this;
    emit<U extends keyof XKeysWatcherEvents>(event: U, ...args: Parameters<XKeysWatcherEvents[U]>): boolean;
}
/**
 * Set up a watcher for newly connected X-keys panels.
 * Note: It is highly recommended to set up a listener for the disconnected event on the X-keys panel, to clean up after a disconnected device.
 */
export declare class XKeysWatcher extends EventEmitter {
    private options?;
    private seenDevicePaths;
    private isMonitoring;
    private updateConnectedDevicesTimeout;
    private shouldFindChangedReTries;
    debug: boolean;
    /** A list of the devices we've called setupXkeysPanels for */
    private setupXkeysPanels;
    private prevConnectedIdentifiers;
    /** Unique unitIds grouped into productId groups. */
    private uniqueIds;
    private pollingInterval;
    constructor(options?: XKeysWatcherOptions | undefined);
    /**
     * Stop the watcher
     * @param closeAllDevices Set to false in order to NOT close all devices. Use this if you only want to stop the watching. Defaults to true
     */
    stop(closeAllDevices?: boolean): Promise<void>;
    private onAddedUSBDevice;
    private onRemovedUSBDevice;
    private triggerUpdateConnectedDevices;
    private updateConnectedDevices;
    private handleNewDevice;
    private _getNextUniqueId;
    private handleRemovedDevice;
    private debugLog;
}
export interface XKeysWatcherOptions {
    /**
     * This activates the "Automatic UnitId mode", which enables several features:
     * First, any x-keys panel with unitId===0 will be issued a (pseudo unique) unitId upon connection, in order for it to be uniquely identified.
     * This allows for the connection-events to work a bit differently, mainly enabling the "reconnected"-event for when a panel has been disconnected, then reconnected again.
     */
    automaticUnitIdMode?: boolean;
    /** If set, will use polling for devices instead of watching for them directly. Might be a bit slower, but is more compatible. */
    usePolling?: boolean;
    /** If usePolling is set, the interval to use for checking for new devices. */
    pollingInterval?: number;
}
//# sourceMappingURL=watcher.d.ts.map