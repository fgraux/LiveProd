"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.XKeysWatcher = void 0;
const events_1 = require("events");
const core_1 = require("@xkeys-lib/core");
const _1 = require(".");
let USBDetectImport;
let hasTriedImport = false;
// Because usb-detection is an optional dependency, we have to use in a somewhat messy way:
function USBDetect() {
    if (USBDetectImport)
        return USBDetectImport;
    if (!hasTriedImport) {
        hasTriedImport = true;
        try {
            // eslint-disable-next-line @typescript-eslint/no-var-requires
            const usbDetection = require('usb-detection');
            USBDetectImport = usbDetection;
            return usbDetection;
        }
        catch (err) {
            // It's not installed
        }
    }
    // else emit error:
    throw `XKeysWatcher requires the dependency "usb-detection" to be installed, it might have been skipped due to your platform being unsupported (this is an issue with "usb-detection", not the X-keys library).
Possible solutions are:
* You can try to install the depencency manually, by running "npm install usb-detection".
* Use the fallback "usePolling" functionality instead: new XKeysWatcher({ usePolling: true})
* Otherwise you can still connect to X-keys panels manually by using XKeys.setupXkeysPanel().
`;
}
let watcherCount = 0;
/**
 * Set up a watcher for newly connected X-keys panels.
 * Note: It is highly recommended to set up a listener for the disconnected event on the X-keys panel, to clean up after a disconnected device.
 */
class XKeysWatcher extends events_1.EventEmitter {
    constructor(options) {
        var _a, _b, _c;
        super();
        this.options = options;
        this.seenDevicePaths = {};
        this.isMonitoring = true;
        this.updateConnectedDevicesTimeout = null;
        this.shouldFindChangedReTries = 0;
        this.debug = false;
        /** A list of the devices we've called setupXkeysPanels for */
        this.setupXkeysPanels = [];
        this.prevConnectedIdentifiers = {};
        /** Unique unitIds grouped into productId groups. */
        this.uniqueIds = new Map();
        this.pollingInterval = undefined;
        this.onAddedUSBDevice = (_device) => {
            // Called whenever a new USB device is added
            this.debugLog('onAddedUSBDevice');
            if (this.isMonitoring) {
                this.shouldFindChangedReTries++;
                this.triggerUpdateConnectedDevices();
            }
        };
        this.onRemovedUSBDevice = (_device) => {
            // Called whenever a new USB device is removed
            this.debugLog('onRemovedUSBDevice');
            if (this.isMonitoring) {
                this.shouldFindChangedReTries++;
                this.triggerUpdateConnectedDevices();
            }
        };
        if (!((_a = this.options) === null || _a === void 0 ? void 0 : _a.usePolling)) {
            watcherCount++;
            if (watcherCount === 1) {
                // We've just started watching
                USBDetect().startMonitoring();
            }
            // Watch for added devices:
            USBDetect().on(`add:${core_1.XKEYS_VENDOR_ID}`, this.onAddedUSBDevice);
            USBDetect().on(`remove:${core_1.XKEYS_VENDOR_ID}`, this.onRemovedUSBDevice);
        }
        else {
            this.pollingInterval = setInterval(() => {
                this.updateConnectedDevices();
            }, (_c = (_b = this.options) === null || _b === void 0 ? void 0 : _b.pollingInterval) !== null && _c !== void 0 ? _c : 1000);
        }
        // Also do a sweep for all currently connected X-keys panels:
        this.updateConnectedDevices();
    }
    /**
     * Stop the watcher
     * @param closeAllDevices Set to false in order to NOT close all devices. Use this if you only want to stop the watching. Defaults to true
     */
    async stop(closeAllDevices = true) {
        var _a;
        this.isMonitoring = false;
        if (!((_a = this.options) === null || _a === void 0 ? void 0 : _a.usePolling)) {
            // Remove the listeners:
            // @ts-expect-error usb-detection exposes wrong types:
            USBDetect().removeListener(`add:${core_1.XKEYS_VENDOR_ID}`, this.onAddedUSBDevice);
            // @ts-expect-error usb-detection exposes wrong types:
            USBDetect().removeListener(`remove:${core_1.XKEYS_VENDOR_ID}`, this.onRemovedUSBDevice);
            watcherCount--;
            if (watcherCount === 0) {
                USBDetect().stopMonitoring();
            }
        }
        if (this.pollingInterval) {
            clearInterval(this.pollingInterval);
            this.pollingInterval = undefined;
        }
        if (closeAllDevices) {
            // In order for an application to close gracefully,
            // we need to close all devices that we've called setupXkeysPanel() on:
            const ps = [];
            for (const xKeysPanel of this.setupXkeysPanels) {
                ps.push(xKeysPanel.close());
            }
            await Promise.all(ps);
        }
    }
    triggerUpdateConnectedDevices(timeout = 100) {
        if (!this.updateConnectedDevicesTimeout) {
            this.updateConnectedDevicesTimeout = setTimeout(() => {
                this.updateConnectedDevicesTimeout = null;
                this.updateConnectedDevices();
            }, timeout);
        }
    }
    updateConnectedDevices() {
        const pathMap = {};
        this.debugLog('updateConnectedDevices');
        // Note:
        // This implementation is a bit awkward,
        // the reason for that is that I couldn't find a good way to relate the output from usb-detection to node-hid devices
        // So we're just using the usb-detection to trigger a re-check for new devices and cache the seen devices
        _1.listAllConnectedPanels().forEach((xkeysDevice) => {
            if (xkeysDevice.path) {
                pathMap[xkeysDevice.path] = true;
            }
            else {
                this.emit('error', `XKeysWatcher: Device missing path.`);
            }
        });
        let removed = 0;
        let added = 0;
        // Removed devices:
        for (const [devicePath, o] of Object.entries(this.seenDevicePaths)) {
            if (!pathMap[devicePath]) {
                // A device has been removed
                this.debugLog('removed');
                removed++;
                if (o.xkeys)
                    this.handleRemovedDevice(o.xkeys);
                delete this.seenDevicePaths[devicePath];
            }
        }
        // Added devices:
        for (const devicePath of Object.keys(pathMap)) {
            if (!this.seenDevicePaths[devicePath]) {
                // A device has been added
                this.debugLog('added');
                added++;
                this.seenDevicePaths[devicePath] = {};
                this.handleNewDevice(devicePath);
            }
        }
        if (this.shouldFindChangedReTries > 0 && (added === 0 || removed === 0)) {
            // We expected to find something changed, but didn't.
            // Try again later:
            this.shouldFindChangedReTries--;
            this.triggerUpdateConnectedDevices(1000);
        }
        else {
            this.shouldFindChangedReTries = 0;
        }
    }
    handleNewDevice(devicePath) {
        this.debugLog('handleNewDevice', devicePath);
        _1.setupXkeysPanel(devicePath)
            .then((xkeysPanel) => {
            var _a;
            this.setupXkeysPanels.push(xkeysPanel);
            // Since this is async, check if the panel is still connected
            if (this.seenDevicePaths[devicePath]) {
                // yes, it is still connected
                // Listen to the disconnected event, because often if comes faster from the X-keys than from this watcher.
                const onDisconnected = () => {
                    delete this.seenDevicePaths[devicePath];
                    xkeysPanel.removeListener('disconnected', onDisconnected);
                };
                xkeysPanel.on('disconnected', onDisconnected);
                // Store for future reference:
                this.seenDevicePaths[devicePath].xkeys = xkeysPanel;
                if ((_a = this.options) === null || _a === void 0 ? void 0 : _a.automaticUnitIdMode) {
                    if (xkeysPanel.unitId === 0) {
                        // if it is 0, we assume that it's new from the factory and can be safely changed
                        xkeysPanel.setUnitId(this._getNextUniqueId(xkeysPanel)); // the lookup-cache is stored either in memory, or preferrably on disk
                    }
                    // the PID+UID pair is enough to uniquely identify a panel.
                    const uniqueIdentifier = xkeysPanel.uniqueId;
                    const previousXKeysPanel = this.prevConnectedIdentifiers[uniqueIdentifier];
                    if (previousXKeysPanel) {
                        // This panel has been connected before.
                        // We want the XKeys-instance to emit a 'reconnected' event.
                        // This means that we kill off the newly created xkeysPanel, and
                        previousXKeysPanel._handleDeviceReconnected(xkeysPanel._getHIDDevice(), xkeysPanel._getDeviceInfo());
                    }
                    else {
                        // It seems that this panel hasn't been connected before
                        this.emit('connected', xkeysPanel);
                        this.prevConnectedIdentifiers[uniqueIdentifier] = xkeysPanel;
                    }
                }
                else {
                    // Default behaviour:
                    this.emit('connected', xkeysPanel);
                }
            }
            else {
                this.handleRemovedDevice(xkeysPanel);
            }
        })
            .catch((err) => {
            this.emit('error', err);
        });
    }
    _getNextUniqueId(xkeysPanel) {
        let nextId = this.uniqueIds.get(xkeysPanel.info.productId);
        if (!nextId) {
            nextId = 32; // Starting at 32
        }
        else {
            nextId++;
        }
        if (nextId > 255)
            throw new Error('No more unique ids available!');
        this.uniqueIds.set(xkeysPanel.info.productId, nextId);
        return nextId;
    }
    handleRemovedDevice(xkeysPanel) {
        xkeysPanel._handleDeviceDisconnected();
    }
    debugLog(...args) {
        if (this.debug)
            console.log(...args);
    }
}
exports.XKeysWatcher = XKeysWatcher;
//# sourceMappingURL=watcher.js.map