"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const net = require("net");
const _ = require("highland");
const AMCP_1 = require("./AMCP");
// Command NS
const AbstractCommand_1 = require("./AbstractCommand");
var IAMCPStatus = AbstractCommand_1.Command.IAMCPStatus;
// Event NS
const Events_1 = require("./event/Events");
const AMCPConnectionOptions_1 = require("./AMCPConnectionOptions");
/**
 *
 */
class CasparCGSocket extends events_1.EventEmitter {
    /**
     *
     */
    constructor(host, port, autoReconnect, autoReconnectInterval, autoReconnectAttempts, queueMode) {
        super();
        this._reconnectAttempt = 0;
        this._commandTimeout = 5000; // @todo make connectionOption!
        this._shouldBeConnected = false;
        this._host = host;
        this._port = port;
        this._reconnectDelay = autoReconnectInterval;
        this._autoReconnect = autoReconnect;
        this._reconnectAttempts = autoReconnectAttempts;
        this.queueMode = queueMode;
    }
    /**
     *
     */
    set autoReconnect(autoReconnect) {
        this._autoReconnect = autoReconnect;
    }
    /**
     *
     */
    set autoReconnectInterval(autoReconnectInterval) {
        this._reconnectDelay = autoReconnectInterval;
    }
    /**
     *
     */
    set autoReconnectAttempts(autoReconnectAttempts) {
        this._reconnectAttempts = autoReconnectAttempts;
    }
    /**
     *
     */
    connect() {
        // prevents manipulation of active socket
        if (!this.connected) {
            // throthling attempts
            if (!this._lastConnectionAttempt || (Date.now() - this._lastConnectionAttempt) >= this._reconnectDelay) { // !_lastReconnectionAttempt means first attempt, OR > _reconnectionDelay since last attempt
                // recereates client if new attempt
                if (this._client && this._client.connecting) {
                    this._client.destroy();
                    this._client.removeAllListeners();
                    delete this._client;
                    // @todo: fire event telling it gives up!
                }
                // (re)creates client, either on first run or new attempt
                if (!this._client) {
                    this._client = new net.Socket();
                    this._client.on('close', (hadError) => this._onClose(hadError));
                    this._client.on('connect', () => this._onConnected());
                    this._client.on('error', (error) => this._onError(error));
                }
                // connects
                this.log('Socket attempting connection');
                this._client.connect(this._port, this._host);
                this._shouldBeConnected = true;
                this._lastConnectionAttempt = Date.now();
            }
            // sets timer to retry when needed
            if (!this._connectionAttemptTimer) {
                this._connectionAttemptTimer = global.setInterval(() => this._autoReconnectionAttempt(), this._reconnectDelay);
            }
        }
    }
    /**
     *
     */
    disconnect() {
        this.dispose();
    }
    /**
     *
     */
    get host() {
        if (this._client) {
            return this._host;
        }
        return this._host;
    }
    /**
     *
     */
    get port() {
        if (this._client) {
            return this._port;
        }
        return this._port;
    }
    /**
     *
     */
    dispose() {
        this._shouldBeConnected = false;
        this._clearConnectionAttemptTimer();
        if (this._client) {
            this._client.destroy();
            delete this._client;
        }
    }
    /**
     *
     */
    log(args) {
        // fallback, this method will be remapped to CasparCG.log by CasparCG on instantiation of socket oject
        console.log(args);
    }
    /**
     */
    set connected(connected) {
        this._connected = connected === true;
        this.emit(Events_1.CasparCGSocketStatusEvent.STATUS, new Events_1.CasparCGSocketStatusEvent(this.socketStatus));
    }
    /**
     *
     */
    get connected() {
        return this._connected;
    }
    /**
     *
     */
    get socketStatus() {
        return {
            connected: this._connected
        };
    }
    /**
     *
     */
    executeCommand(command) {
        let commandString;
        if (this.queueMode === AMCPConnectionOptions_1.Options.QueueMode.SALVO)
            commandString = `REQ ${command.token} ` + command.constructor['commandString'] + (command.address ? ' ' + command.address : '');
        else
            commandString = command.constructor['commandString'] + (command.address ? ' ' + command.address : '');
        for (let i in command.payload) {
            let payload = command.payload[i];
            commandString += (commandString.length > 0 ? ' ' : '');
            commandString += (payload.key ? payload.key + ' ' : '') + payload.value;
        }
        global.clearTimeout(this._commandTimeoutTimer);
        this._commandTimeoutTimer = global.setTimeout(() => this._onTimeout(), this._commandTimeout);
        this._client.write(`${commandString}\r\n`);
        command.status = IAMCPStatus.Sent;
        this.log(commandString);
        return command;
    }
    /**
     *
     */
    _autoReconnectionAttempt() {
        if (this._autoReconnect) {
            if (this._reconnectAttempts > 0) { // no reconnection if no valid reconnectionAttemps is set
                if ((this._reconnectAttempt >= this._reconnectAttempts)) { // if current attempt is not less than max attempts
                    // reset reconnection behaviour
                    this._clearConnectionAttemptTimer();
                    return;
                }
                // new attempt if not allready connected
                if (!this.connected) {
                    this._reconnectAttempt++;
                    this.connect();
                }
            }
        }
    }
    /**
     *
     */
    _clearConnectionAttemptTimer() {
        // @todo create event telling reconnection ended with result: true/false
        // only if reconnection interval is true
        this._reconnectAttempt = 0;
        global.clearInterval(this._connectionAttemptTimer);
        delete this._connectionAttemptTimer;
    }
    /**
     *
     */
    _onTimeout() {
        global.clearTimeout(this._commandTimeoutTimer);
        this.emit(Events_1.CasparCGSocketStatusEvent.TIMEOUT, new Events_1.CasparCGSocketStatusEvent(this.socketStatus));
    }
    /**
     *
     */
    _onConnected() {
        this._clearConnectionAttemptTimer();
        _(this._client).splitBy(/(?=\r\n)/).errors((error) => this._onError(error)).each((i) => this._parseResponseGroups(i));
        this.connected = true;
    }
    /**
     *
     */
    _parseResponseGroups(i) {
        global.clearTimeout(this._commandTimeoutTimer);
        i = (i.length > 2 && i.slice(0, 2) === '\r\n') ? i.slice(2) : i;
        if (AMCP_1.AMCPUtil.CasparCGSocketResponse.evaluateStatusCode(i) === 200) {
            this._parsedResponse = new AMCP_1.AMCPUtil.CasparCGSocketResponse(i);
            this._commandTimeoutTimer = global.setTimeout(() => this._onTimeout(), this._commandTimeout);
            return;
        }
        else if (this._parsedResponse && this._parsedResponse.statusCode === 200) {
            if (i !== '\r\n') {
                this._parsedResponse.items.push(i);
                this._commandTimeoutTimer = global.setTimeout(() => this._onTimeout(), this._commandTimeout);
                return;
            }
            else {
                this.emit(Events_1.CasparCGSocketResponseEvent.RESPONSE, new Events_1.CasparCGSocketResponseEvent(this._parsedResponse));
                this._parsedResponse = undefined;
                return;
            }
        }
        else if (AMCP_1.AMCPUtil.CasparCGSocketResponse.evaluateStatusCode(i) === 201 || AMCP_1.AMCPUtil.CasparCGSocketResponse.evaluateStatusCode(i) === 400 || AMCP_1.AMCPUtil.CasparCGSocketResponse.evaluateStatusCode(i) === 101) {
            this._parsedResponse = new AMCP_1.AMCPUtil.CasparCGSocketResponse(i);
            this._commandTimeoutTimer = global.setTimeout(() => this._onTimeout(), this._commandTimeout);
            return;
        }
        else if (this._parsedResponse && this._parsedResponse.statusCode === 201 || this._parsedResponse && this._parsedResponse.statusCode === 400 || this._parsedResponse && this._parsedResponse.statusCode === 101) {
            this._parsedResponse.items.push(i);
            this.emit(Events_1.CasparCGSocketResponseEvent.RESPONSE, new Events_1.CasparCGSocketResponseEvent(this._parsedResponse));
            this._parsedResponse = undefined;
            return;
        }
        else {
            let parsedResponse = new AMCP_1.AMCPUtil.CasparCGSocketResponse(i);
            if (!isNaN(parsedResponse.statusCode)) {
                this.emit(Events_1.CasparCGSocketResponseEvent.RESPONSE, new Events_1.CasparCGSocketResponseEvent(parsedResponse));
                return;
            }
            else {
                this.emit(Events_1.CasparCGSocketResponseEvent.INVALID_RESPONSE, new Events_1.CasparCGSocketResponseEvent(parsedResponse));
                return;
            }
        }
    }
    /**
     * @todo:::
     */
    _onError(error) {
        // dispatch error!!!!!
        this.log(`Socket event error: ${error.message}`);
    }
    /**
     *
     */
    _onClose(hadError) {
        this.connected = false;
        if (hadError) {
            this.log('Socket closed with error');
        }
        else {
            this.log('Socket closed without error');
        }
        if (this._shouldBeConnected === true) {
            this.log('Socket should reconnect');
            this.connect();
        }
    }
}
exports.CasparCGSocket = CasparCGSocket;
//# sourceMappingURL=CasparCGSocket.js.map