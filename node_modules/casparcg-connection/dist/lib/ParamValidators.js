"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ServerStateEnum_1 = require("./ServerStateEnum");
const AbstractCommand_1 = require("./AbstractCommand");
var Validation;
(function (Validation) {
    /**
     *
     */
    class AbstractValidator {
        constructor() {
            this.resolved = false;
        }
    }
    Validation.AbstractValidator = AbstractValidator;
    /**
     *
     */
    class StringValidator extends AbstractValidator {
        /**
         *
         */
        constructor(lazy = true) {
            super();
            this.lazy = lazy;
        }
        /**
         *
         */
        resolve(data) {
            let textstring = '';
            function checkTextstring(rawClipNameString) {
                if (rawClipNameString === null) {
                    return '';
                }
                // trim all non-textual content
                rawClipNameString = rawClipNameString.trim();
                // check length
                if (rawClipNameString.length === 0) {
                    return '';
                }
                return rawClipNameString;
            }
            if (Array.isArray(data)) {
                let i = 0;
                // switch lazy/greedy mode
                if (this.lazy) {
                    // lazy = return first valid hit
                    do {
                        textstring = checkTextstring(data[i]);
                        i++;
                    } while (textstring.length === 0);
                }
                else {
                    // greedy
                    textstring = '';
                    data.forEach(i => {
                        let o = checkTextstring(i);
                        textstring += (o) ? o + ' ' : '';
                    });
                }
            }
            else if (typeof data === 'object' || typeof data === 'string') {
                textstring = data.toString();
            }
            if (!checkTextstring(textstring)) {
                return false;
            }
            return textstring;
        }
    }
    Validation.StringValidator = StringValidator;
    /***/
    class FilterValidator extends StringValidator {
        /**
         *
         */
        resolve(data) {
            let clipName = '';
            if (typeof data === 'object' || typeof data === 'string') {
                clipName = data !== null ? data.toString() : '';
            }
            // add quotation
            let quotedClipName = `"${clipName}"`;
            return { raw: clipName, payload: quotedClipName };
        }
    }
    Validation.FilterValidator = FilterValidator;
    /***/
    class URLValidator extends StringValidator {
        resolve(data) {
            let url = super.resolve(data).toString();
            // add quotation
            let quotedUrl = `"${url}"`;
            return { raw: url, payload: quotedUrl };
        }
    }
    Validation.URLValidator = URLValidator;
    /***/
    class ChannelLayoutValidator extends StringValidator {
    }
    Validation.ChannelLayoutValidator = ChannelLayoutValidator;
    /**
     *
     */
    class ClipNameValidator extends AbstractValidator {
        /**
         *
         */
        resolve(data) {
            let clipName = '';
            if (typeof data === 'object' || typeof data === 'string') {
                clipName = data !== null ? data.toString() : '';
            }
            if (!this.checkClipNameString(clipName)) {
                return false;
            }
            // add quotation
            let quotedClipName = `"${clipName}"`;
            return { raw: clipName, payload: quotedClipName };
        }
        checkClipNameString(rawClipNameString) {
            if (rawClipNameString === null) {
                return '';
            }
            // trim all non-textual content
            rawClipNameString = rawClipNameString.trim();
            // check length
            if (rawClipNameString.length === 0) {
                return '';
            }
            return rawClipNameString;
        }
    }
    Validation.ClipNameValidator = ClipNameValidator;
    /**
     *
     */
    class ClipNameEmptyStringValidator extends ClipNameValidator {
        resolve(data) {
            let clipName = '';
            if (typeof data === 'object' || typeof data === 'string') {
                clipName = data !== null ? data.toString() : '';
            }
            if (!this.checkClipNameString(clipName) && clipName !== '') {
                return false;
            }
            // add quotation
            let quotedClipName = `"${clipName}"`;
            return { raw: clipName, payload: quotedClipName };
        }
    }
    Validation.ClipNameEmptyStringValidator = ClipNameEmptyStringValidator;
    /**
     *
     */
    class TemplateNameValidator extends ClipNameValidator {
    }
    Validation.TemplateNameValidator = TemplateNameValidator;
    /**
     *
     */
    class DataNameValidator extends ClipNameValidator {
    }
    Validation.DataNameValidator = DataNameValidator;
    /**
     *
     */
    class EnumValidator extends AbstractValidator {
        /**
         *
         */
        constructor(_enumClass) {
            super();
            this._enumClass = _enumClass;
        }
        /**
         *
         */
        resolve(data) {
            if (data instanceof this._enumClass) {
                return data.value;
            }
            else if (typeof data === 'string') {
                // TODO: data is known to be string here;
                let stringCast = data; // !== null ? data.toString() : ''
                // format stringy enum value
                stringCast = stringCast.toUpperCase();
                stringCast = stringCast.replace(' ', '_');
                if (this._enumClass.hasOwnProperty(stringCast)) {
                    return this._enumClass[stringCast].value;
                }
            }
            return false;
        }
    }
    Validation.EnumValidator = EnumValidator;
    /**
     *
     */
    class ChannelFormatValidator extends AbstractValidator {
        /**
         *
         */
        constructor() {
            super();
        }
        /**
         *
         */
        resolve(data) {
            if (data instanceof ServerStateEnum_1.Enum.ChannelFormat) {
                return data.value;
            }
            else if (typeof data === 'string') {
                let stringCast = data.toString();
                // format stringy enum value
                stringCast = stringCast.toUpperCase();
                stringCast = stringCast.replace(' ', '_');
                if (ServerStateEnum_1.Enum.ChannelFormat.hasOwnProperty(stringCast)) {
                    return ServerStateEnum_1.Enum.ChannelFormat[stringCast].value;
                }
                else if (ServerStateEnum_1.Enum.ChannelFormat.hasOwnProperty('SD_' + stringCast)) {
                    return ServerStateEnum_1.Enum.ChannelFormat['SD_' + stringCast].value;
                }
                else if (ServerStateEnum_1.Enum.ChannelFormat.hasOwnProperty('HD_' + stringCast)) {
                    return ServerStateEnum_1.Enum.ChannelFormat['HD_' + stringCast].value;
                }
                else if (ServerStateEnum_1.Enum.ChannelFormat.hasOwnProperty('UHD_' + stringCast)) {
                    return ServerStateEnum_1.Enum.ChannelFormat['UHD_' + stringCast].value;
                }
            }
            return false;
        }
    }
    Validation.ChannelFormatValidator = ChannelFormatValidator;
    /**
     *
     */
    class KeywordValidator extends AbstractValidator {
        /**
         *
         */
        constructor(keyword, caseSensitive = false) {
            super();
            this._keyword = keyword;
            this._caseSensitive = caseSensitive;
        }
        /**
         *
         */
        resolve(data) {
            let keywordCopy = this._keyword;
            if (!this._caseSensitive) {
                keywordCopy = keywordCopy.toLowerCase();
            }
            if (Array.isArray(data)) {
                if (!this._caseSensitive) {
                    data = data.map(value => String(value).toLowerCase());
                }
                if (data.indexOf(keywordCopy) > -1) {
                    return this._keyword;
                }
            }
            else if (typeof data === 'object' && data !== null) {
                let objectCast = data;
                if (!this._caseSensitive) {
                    for (let key in objectCast) {
                        objectCast[key] = String(objectCast[key]).toLowerCase();
                    }
                }
                if (objectCast.hasOwnProperty(keywordCopy)) {
                    return this._keyword;
                }
            }
            else if (typeof data === 'string') {
                if (!this._caseSensitive) {
                    data = String(data).toLowerCase();
                }
                if (data === keywordCopy) {
                    return this._keyword;
                }
            }
            return false;
        }
    }
    Validation.KeywordValidator = KeywordValidator;
    /**
     *
     */
    class FrameValidator extends AbstractValidator {
        /**
         *
         */
        constructor(keyword) {
            super();
            this._keyword = keyword;
        }
        /**
         *
         */
        resolve(data) {
            if (Array.isArray(data)) {
                data = data.map(element => String(element).toLowerCase());
                let index = data.indexOf(this._keyword.toLowerCase());
                if (index > -1) {
                    data = parseInt(data[index + 1], 10);
                }
            }
            else if (typeof data === 'object' && data !== null) {
                let objectCast = data;
                if (objectCast.hasOwnProperty(this._keyword)) {
                    data = objectCast[this._keyword];
                }
            }
            else if (typeof data === 'string') {
                data = Number(data);
            }
            if (typeof data === 'number') {
                let numberCast = data;
                if (numberCast >= 0) {
                    return numberCast;
                }
            }
            return false;
        }
    }
    Validation.FrameValidator = FrameValidator;
    /**
     *
     */
    class PositiveNumberValidatorBetween extends AbstractValidator {
        /**
         *
         */
        constructor(_min = 0, _max = Number.POSITIVE_INFINITY) {
            super();
            this._min = _min;
            this._max = _max;
        }
        /**
         *
         */
        resolve(data) {
            if (typeof data === 'number') {
                let numberCast = Math.max(Math.min(data, this._max), this._min);
                if (numberCast >= 0) {
                    return numberCast;
                }
            }
            return false;
        }
    }
    Validation.PositiveNumberValidatorBetween = PositiveNumberValidatorBetween;
    /**
     *
     */
    class PositiveNumberValidator extends PositiveNumberValidatorBetween {
        /**
         *
         */
        constructor() {
            super();
        }
    }
    Validation.PositiveNumberValidator = PositiveNumberValidator;
    /**
     *
     */
    class PositiveNumberRoundValidatorBetween extends PositiveNumberValidatorBetween {
        /**
         *
         */
        resolve(data) {
            return Number(super.resolve(data)).toFixed();
        }
    }
    Validation.PositiveNumberRoundValidatorBetween = PositiveNumberRoundValidatorBetween;
    /**
     *
     */
    class NumberValidatorBetween extends AbstractValidator {
        /**
         *
         */
        constructor(_min = Number.NEGATIVE_INFINITY, _max = Number.POSITIVE_INFINITY) {
            super();
            this._min = _min;
            this._max = _max;
        }
        /**
         *
         */
        resolve(data) {
            if (typeof data === 'number') {
                let numberCast = Math.max(Math.min(data, this._max), this._min);
                return numberCast;
            }
            return false;
        }
    }
    Validation.NumberValidatorBetween = NumberValidatorBetween;
    /**
     *
     */
    class NumberValidator extends NumberValidatorBetween {
        /**
         *
         */
        constructor() {
            super();
        }
    }
    Validation.NumberValidator = NumberValidator;
    /***/
    class DecklinkDeviceValidator extends PositiveNumberValidator {
    }
    Validation.DecklinkDeviceValidator = DecklinkDeviceValidator;
    /**
     *
     */
    class BooleanValidatorWithDefaults extends AbstractValidator {
        /**
         *
         */
        constructor(_valueOnSuccess, _valueOnFail) {
            super();
            this._valueOnSuccess = _valueOnSuccess;
            this._valueOnFail = _valueOnFail;
        }
        /**
         *
         */
        resolve(data, key) {
            if (Array.isArray(data)) {
                data = data.map(element => String(element).toLowerCase());
                let index = data.indexOf(key.toLowerCase());
                if (index > -1) {
                    data = data[index + 1];
                    if (data === undefined) {
                        data = data[index];
                    }
                    // @todo: probably add some string-parsing logic:
                    // if just a single boolean param in protocol, try to parse arrayCast[0] which should hold it
                }
                else {
                    // can't resolve array
                    data = false;
                }
            }
            let isValid = false;
            if (typeof data === 'string') {
                if (data === 'true') {
                    isValid = true;
                }
                else if (data === '1') {
                    isValid = true;
                }
                else if (data === key) {
                    isValid = true;
                }
            }
            else {
                isValid = (!!data.valueOf());
            }
            if (isValid) {
                return (this._valueOnSuccess !== undefined) ? this._valueOnSuccess : isValid;
            }
            else {
                return (this._valueOnFail !== undefined) ? this._valueOnFail : isValid;
            }
        }
    }
    Validation.BooleanValidatorWithDefaults = BooleanValidatorWithDefaults;
    /**
     *
     */
    class BooleanValidator extends BooleanValidatorWithDefaults {
        /**
         *
         */
        constructor() {
            super();
        }
    }
    Validation.BooleanValidator = BooleanValidator;
    /**
     *
     */
    class TemplateDataValidator extends AbstractValidator {
        /**
         *
         */
        resolve(data) {
            let stringCast = data.toString();
            // data is object: serialize
            if (typeof data === 'object') {
                stringCast = JSON.stringify(data);
            }
            else {
                stringCast = stringCast.replace(/\r|\n/g, charToEscape => {
                    return charToEscape === '\r' ? '\\r' : '\\n';
                });
            }
            /*	// data is string, try to de-serialize to validate as JSON
                try {
                    let objectCast = JSON.parse(stringCast);
                    return stringCast;
                } catch (e) {}

                // data is string, try to de-serialize to validate as XML
                let xmlCast;
                parseString(stringCast, {async: false}, (err, res) => {
                    if (res) {
                        xmlCast = res;
                    }
                });
                if (xmlCast) {
                    return stringCast;
                }*/
            // escaping
            stringCast = stringCast.replace(/([\\\"])/g, '\\$1');
            // add qoutation
            let quotedString = `"${stringCast}"`;
            return { raw: stringCast, payload: quotedString };
        }
    }
    Validation.TemplateDataValidator = TemplateDataValidator;
    class TimecodeValidator extends StringValidator {
    }
    Validation.TimecodeValidator = TimecodeValidator;
    class RouteValidator extends AbstractValidator {
        constructor() {
            super(...arguments);
            this.regex = new RegExp(/(route:\/\/)\d+((-)\d+)?/g);
            this.regex2 = new RegExp(/\d+((-)\d+)?/g);
        }
        resolve(data) {
            if (typeof data === 'string') {
                if (this.regex.test(data)) {
                    return { raw: data, payload: data };
                }
                else if (this.regex2.test(data)) {
                    return { raw: data, payload: 'route://' + data };
                }
                else {
                    return false;
                }
            }
            else if (typeof data === 'object') { // data is an object
                let routeStr = 'route://';
                if (data.channel) {
                    routeStr += data.channel;
                    if (data.layer) {
                        routeStr += '-' + data.layer;
                    }
                    return { raw: data.toString(), payload: routeStr };
                }
                else {
                    return false;
                }
            }
            else {
                return false;
            }
        }
    }
    Validation.RouteValidator = RouteValidator;
    class RouteFramesDelayValidator extends PositiveNumberValidator {
    }
    Validation.RouteFramesDelayValidator = RouteFramesDelayValidator;
    class RouteModeValidator extends StringValidator {
    }
    Validation.RouteModeValidator = RouteModeValidator;
    class CommandValidator extends AbstractValidator {
        resolve(command) {
            if (AbstractCommand_1.Command.isIAMCPCommand(command)) {
                command.validateParams();
                // TODO: The `command.constructor.commandString` is probably a bug, or at best bad pratice to name a paramter "constructur", as it is reserved.
                let commandString = command.constructor.commandString + (command.address ? ' ' + command.address : '');
                for (let i in command.payload) {
                    let payload = command.payload[i];
                    commandString += (commandString.length > 0 ? ' ' : '');
                    commandString += (payload.key ? payload.key + ' ' : '') + payload.value;
                }
                return commandString;
            }
            else {
                throw new Error('Argument 0 was not an amcp command.');
            }
        }
    }
    Validation.CommandValidator = CommandValidator;
    class StingTransitionPropertiesValidator extends AbstractValidator {
        constructor() {
            super(...arguments);
            this.regex = new RegExp(/\(((\w+=(((?:").*(?:"))+|(\d+)))( )?)*\)/g);
            this.props = {};
        }
        resolve(data) {
            if (!data)
                return false;
            if (typeof data === 'string' && this.regex.test(data)) {
                return { raw: data, payload: data };
            }
            else if (typeof data === 'object') { // data is an object
                this.props = data;
                let str = '(';
                if (this.props.maskFile)
                    str += `MASK="${this.props.maskFile}" `;
                if (this.props.overlayFile)
                    str += `OVERLAY="${this.props.overlayFile}" `;
                if (this.props.delay)
                    str += `TRIGGER_POINT="${this.props.delay}" `;
                if (this.props.audioFadeStart)
                    str += `AUDIO_FADE_START="${this.props.audioFadeStart}" `;
                if (this.props.audioFadeDuration)
                    str += `AUDIO_FADE_DURATION="${this.props.audioFadeDuration}" `;
                str = str.substr(0, str.length - 1) + ')';
                return { raw: JSON.stringify(data), payload: str };
            }
            else {
                return false;
            }
        }
    }
    Validation.StingTransitionPropertiesValidator = StingTransitionPropertiesValidator;
})(Validation = exports.Validation || (exports.Validation = {}));
//# sourceMappingURL=ParamValidators.js.map