"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const CasparCGSocket_1 = require("./lib/CasparCGSocket");
const AMCP_1 = require("./lib/AMCP");
const ServerStateEnum_1 = require("./lib/ServerStateEnum");
const AMCPConnectionOptions_1 = require("./lib/AMCPConnectionOptions");
// Options NS
var QueueMode = AMCPConnectionOptions_1.Options.QueueMode;
var CasparCGVersion = AMCPConnectionOptions_1.Options.CasparCGVersion;
// Command NS
const AbstractCommand_1 = require("./lib/AbstractCommand");
var isIAMCPCommand = AbstractCommand_1.Command.isIAMCPCommand;
var IAMCPStatus = AbstractCommand_1.Command.IAMCPStatus;
var AMCPResponse = AbstractCommand_1.Command.AMCPResponse;
// Event NS
const Events_1 = require("./lib/event/Events");
var Priority;
(function (Priority) {
    Priority[Priority["LOW"] = 0] = "LOW";
    Priority[Priority["NORMAL"] = 1] = "NORMAL";
    Priority[Priority["HIGH"] = 2] = "HIGH";
})(Priority = exports.Priority || (exports.Priority = {}));
/**
 * The main object and entrypoint for all interactions. `CasparCG` allows for flexible configuration, re-configuration and events/callbacks.
 * It implements all [[AMCP]] commands as high-level methods with convenient interfaces.
 *
 * There is a single [[CasparCGSocket]] pr. `CasparCG` object.
 * `CasparCG` should be the only public interface to interact directly with.
 */
class CasparCG extends events_1.EventEmitter {
    constructor(hostOrOptions, port) {
        super();
        /**
         * Try to connect upon creation.
         */
        this.autoConnect = undefined;
        /**
         * Setting this to true will investigate all connections to assess if the server is freshly booted, or have been used before the connection
         */
        this.virginServerCheck = undefined;
        /**
         * Setting this to true will print out logging to the `Console`, in addition to the optinal [[onLog]] and [[LogEvent.LOG]]
         */
        this.debug = undefined;
        /**
         * Callback for all logging.
         */
        this.onLog = undefined;
        /**
         * Callback for all status updates from the `CasparCGSocket`.
         */
        this.onConnectionStatus = undefined;
        /**
         * Callback for status updates from the `CasparCGSocket` if the `connected` property changes value.
         */
        this.onConnectionChanged = undefined;
        /**
         * Callback for status updates from the `CasparCGSocket` if the `connected` property is set to `true`.
         */
        this.onConnected = undefined;
        /**
         * Callback for status updates from the `CasparCGSocket` if the `connected` property is set to `false`.
         */
        this.onDisconnected = undefined;
        /**
         * Callback for general errors
         */
        this.onError = undefined;
        this._connected = false;
        this._queuedCommands = [];
        this._queuedCommandsLowPriority = [];
        this._queuedCommandsHighPriority = [];
        this._sentCommands = {};
        let options;
        if (typeof hostOrOptions === 'object') {
            options = new AMCPConnectionOptions_1.ConnectionOptions(hostOrOptions);
        }
        else {
            options = new AMCPConnectionOptions_1.ConnectionOptions(hostOrOptions, port);
        }
        // if both options and port specified, port overrides options
        if (port && (port !== options.port)) {
            options.port = port;
        }
        this._createNewSocket(options);
        if (this.autoConnect) {
            this.connect();
        }
    }
    /**
     * Creates a new [[CasparCGSocket]] and connects.
     *
     * @param options	Setting new [[ICasparCGConnection]] properties will override each individual property allready defined on the `CasparCG` object. Existing properties not overwritten by this `options` object will remain.
     */
    connect(options) {
        // recreate socket if new options
        if (options) {
            this._createNewSocket(options);
        }
        if (this._socket) {
            this._socket.connect();
        }
    }
    /**
     * Disconnects and disposes the [[CasparCGSocket]] connection.
     */
    disconnect() {
        if (this._socket) {
            this._socket.disconnect();
        }
    }
    /**
     *
     */
    reconnect() {
        this._createNewSocket(undefined, true);
        this.connect();
    }
    /**
     *
     */
    get host() {
        return this._host;
    }
    /**
     * Setting the `host` will create a new [[CasparCGSocket]] connection.
     *
     * The new `CasparCGSocket` will `autoConnect` if the old socket was either successfully connected, or currently reconnecting. Changing the host resets the number of [[CasparCG.autoReconnectAttempts]].
     */
    set host(host) {
        if (this._host !== host) {
            this._host = host;
            let shouldReconnect = this.connected;
            this._createNewSocket();
            if (shouldReconnect) {
                this.connect();
            }
        }
    }
    /**
     *
     */
    get port() {
        return this._port;
    }
    /**
     * Setting the `port` will create a new [[CasparCGSocket]] connection.
     *
     * The new `CasparCGSocket` will `autoConnect` if the old socket was either successfully connected, or currently reconnecting. Changing the host resets the number of [[CasparCG.autoReconnectAttempts]].
     */
    set port(port) {
        if (this._port !== port) {
            this._port = port;
            let shouldReconnect = this.connected;
            this._createNewSocket();
            if (shouldReconnect) {
                this.connect();
            }
        }
    }
    /**
     * Try to reconnect in case of unintentionally loss of connection, or in case of failed connection in the first place.
     */
    get autoReconnect() {
        return this._autoReconnect;
    }
    /**
     *
     */
    set autoReconnect(autoReconnect) {
        this._autoReconnect = autoReconnect;
        if (this._socket) {
            this._socket.autoReconnect = this._autoReconnect;
        }
    }
    /**
     * Timeout in milliseconds between each connection attempt during reconnection.
     */
    get autoReconnectInterval() {
        return this._autoReconnectInterval;
    }
    /**
     *
     */
    set autoReconnectInterval(autoReconnectInterval) {
        this._autoReconnectInterval = autoReconnectInterval;
        if (this._socket) {
            this._socket.autoReconnectInterval = this._autoReconnectInterval;
        }
    }
    /**
     * Max number of attempts of connection during reconnection. This value resets once the reconnection is over (either in case of successfully reconnecting, changed connection properties such as `host` or `port` or by being manually cancelled).
     */
    get autoReconnectAttempts() {
        return this._autoReconnectAttempts;
    }
    /**
     *
     */
    set autoReconnectAttempts(autoReconnectAttempts) {
        this._autoReconnectAttempts = autoReconnectAttempts;
        if (this._socket) {
            this._socket.autoReconnectAttempts = this._autoReconnectAttempts;
        }
    }
    /**
     *
     */
    get connectionOptions() {
        let options = new AMCPConnectionOptions_1.ConnectionOptions({});
        for (let key in options) {
            if (this.hasOwnProperty(key) || CasparCG.hasOwnProperty(key)) {
                options[key] = this[key];
            }
        }
        return options;
    }
    /**
     *
     */
    get connected() {
        return this._connected || false;
    }
    /**
     *
     */
    get connectionStatus() {
        return this._socket.socketStatus;
    }
    /**
     *
     */
    set serverVersion(version) {
        if (version) {
            this._userConfigServerVersion = version;
        }
    }
    /**
     *
     */
    get serverVersion() {
        if (this._userConfigServerVersion) {
            return this._userConfigServerVersion;
        }
        return undefined;
    }
    get queueMode() {
        return this._queueMode;
    }
    set queueMode(mode) {
        if (this._queueMode === QueueMode.SEQUENTIAL && mode === QueueMode.SALVO && Object.keys(this._sentCommands).length) {
            this._log('Warning: setting queuemode to SALVO while there is a sequential command being sent will return undocumente behaviour!');
            // @todo: await for current command to return, and then set queue mode.
        }
        this._queueMode = mode;
        if (this._socket) {
            this._socket.queueMode = mode;
        }
    }
    /**
     *
     */
    get commandQueueLength() {
        return this._queuedCommands.length + this._queuedCommandsLowPriority.length + this._queuedCommandsHighPriority.length;
    }
    do(commandOrString, ...params) {
        let command = this.createCommand(commandOrString, ...params);
        if (command) {
            return this.queueCommand(command);
        }
        return Promise.reject('Could not create command instance');
    }
    doNow(commandOrString, ...params) {
        let command = this.createCommand(commandOrString, ...params);
        if (command) {
            return this.queueCommand(command, Priority.HIGH);
        }
        return Promise.reject('Could not create command instance');
    }
    doLater(commandOrString, ...params) {
        let command = this.createCommand(commandOrString, ...params);
        if (command) {
            return this.queueCommand(command, Priority.LOW);
        }
        return Promise.reject('Could not create command instance');
    }
    /**
     *
     */
    createCommand(commandOrString, ...params) {
        let command;
        try {
            if (isIAMCPCommand(commandOrString)) {
                command = commandOrString;
            }
            else { // then it must be a string:
                if (AMCP_1.AMCP.hasOwnProperty(commandOrString)) {
                    // @todo: parse out params from commandString, if Params is empty and commandString.split(" ").length > 1
                    // @todo: typechecking with fallback
                    if (AMCP_1.AMCP[commandOrString]) {
                        command = new AMCP_1.AMCP(commandOrString)(params);
                    }
                    else {
                        throw new Error('Invalid command constructor');
                    }
                }
            }
            // validate command and params
            if (!command || !command.validateParams()) {
                // @todo: Handle, return?
                throw new Error('Invalid command parameters');
            }
            return command;
        }
        catch (error) {
            this._log(error);
        }
        return undefined;
    }
    /**
     *
     */
    queueCommand(command, priority = Priority.NORMAL) {
        let commandPromise;
        let commandPromiseArray = [new Promise((resolve, reject) => {
                command.resolve = resolve;
                command.reject = reject;
            })];
        if (command.name === 'ScheduleSetCommand') {
            let subCommand = command.getParam('command');
            commandPromiseArray.push(new Promise((resolve, reject) => {
                subCommand.resolve = resolve;
                subCommand.reject = reject;
            }));
        }
        commandPromise = Promise.all(commandPromiseArray);
        commandPromise.catch((error) => {
            // @todo: global command error handler here
            this._log(new Error('Command error: ' + error.toString()));
        });
        switch (priority) {
            case Priority.NORMAL:
                this._queuedCommands.push(command);
                break;
            case Priority.HIGH:
                this._queuedCommandsHighPriority.push(command);
                break;
            case Priority.LOW:
                this._queuedCommandsLowPriority.push(command);
                break;
        }
        this._log(`New command added, "${command.name}". ${this.commandQueueLength} command(s) in command queues.`);
        command.status = IAMCPStatus.Queued;
        this._executeNextCommand();
        return new Promise((outerResolve, outerReject) => {
            commandPromise.then((cmds) => [
                outerResolve(cmds[cmds.length - 1]) // resolve with last executed command
            ]).catch((err) => {
                outerReject(err);
            });
        });
    }
    /**
     * @todo: document
     */
    removeQueuedCommand(id) {
        let removed;
        // normal priority
        for (let i = 0; i < this._queuedCommands.length; i++) {
            let o = this._queuedCommands[i];
            if (o.id === id) {
                removed = this._queuedCommands.splice(i, 1);
                this._log(`Command removed, "${removed[0].name}". ${this.commandQueueLength} command(s) left in command queues.`);
                break;
            }
        }
        // high priority
        if (!removed) {
            for (let i = 0; i < this._queuedCommandsHighPriority.length; i++) {
                let o = this._queuedCommandsHighPriority[i];
                if (o.id === id) {
                    removed = this._queuedCommandsHighPriority.splice(i, 1);
                    this._log(`Command removed, "${removed[0].name}". ${this.commandQueueLength} command(s) left in command queues.`);
                    break;
                }
            }
        }
        // low priority
        if (!removed) {
            for (let i = 0; i < this._queuedCommandsLowPriority.length; i++) {
                let o = this._queuedCommandsLowPriority[i];
                if (o.id === id) {
                    removed = this._queuedCommandsLowPriority.splice(i, 1);
                    this._log(`Command removed, "${removed[0].name}". ${this.commandQueueLength} command(s) left in command queues.`);
                    break;
                }
            }
        }
        return Array.isArray(removed) && removed.length > 0;
    }
    /***/
    getCasparCGConfig(refresh = false) {
        if (!this._configPromise || refresh) {
            this._configPromise = new Promise((resolve, reject) => {
                this.infoConfig().then((response) => {
                    resolve(response.response.data);
                }).catch(reject);
            });
        }
        return this._configPromise;
    }
    /***/
    getCasparCGPaths(refresh = false) {
        if (!this._pathsPromise || refresh) {
            this._pathsPromise = new Promise((resolve, reject) => {
                this.infoPaths().then((response) => {
                    resolve(response.response.data);
                }).catch(reject);
            });
        }
        return this._pathsPromise;
    }
    /***/
    getCasparCGVersion(refresh = false) {
        if (!this._versionPromise || refresh) {
            // use configed version
            if (this._userConfigServerVersion) {
                this._versionPromise = new Promise((resolve) => resolve(this._userConfigServerVersion));
                // generate version
            }
            else {
                this._versionPromise = new Promise((resolve, reject) => {
                    this.doNow(new AMCP_1.AMCP.VersionCommand({ component: ServerStateEnum_1.Enum.Version.SERVER })).then((response) => {
                        let versionString = response.response.data.toString().slice(0, 5);
                        let version = CasparCGVersion.V2xx;
                        switch (versionString) {
                            case '2.0.7':
                                version = CasparCGVersion.V207;
                                break;
                            case '2.1.0':
                                version = CasparCGVersion.V210;
                                break;
                        }
                        resolve(version);
                    }).catch(reject);
                });
            }
        }
        return this._versionPromise;
    }
    loadbg(channel, layer = NaN, clip, loop, transition, transitionDurationOrMaskFileOrProps, transitionEasingOrStingDuration, transitionDirectionOrOverlay, seek, length, filter, auto, channelLayout, clearOn404) {
        return this.do(new AMCP_1.AMCP.LoadbgCommand({ channel: channel, layer: layer, clip: clip, loop: loop, transition: transition, ...this._createTransitionOptionsObject(transition, transitionDurationOrMaskFileOrProps, transitionEasingOrStingDuration, transitionDirectionOrOverlay), seek: seek, length: length, filter: filter, auto: auto, channelLayout, clearOn404 }));
    }
    loadbgAuto(channel, layer = NaN, clip, loop, transition, transitionDurationOrMaskFileOrProps, transitionEasingOrStingDuration, transitionDirectionOrOverlay, seek, length, filter, channelLayout, clearOn404) {
        return this.do(new AMCP_1.AMCP.LoadbgCommand({ channel: channel, layer: layer, clip: clip, loop: loop, transition: transition, ...this._createTransitionOptionsObject(transition, transitionDurationOrMaskFileOrProps, transitionEasingOrStingDuration, transitionDirectionOrOverlay), seek: seek, length: length, filter: filter, auto: true, channelLayout, clearOn404 }));
    }
    load(channel, layer = NaN, clip, loop, transition, transitionDurationOrMaskFileOrProps, transitionEasingOrStingDuration, transitionDirectionOrOverlay, seek, length, filter, channelLayout, clearOn404) {
        return this.do(new AMCP_1.AMCP.LoadCommand({ channel: channel, layer: layer, clip: clip, loop: loop, transition: transition, ...this._createTransitionOptionsObject(transition, transitionDurationOrMaskFileOrProps, transitionEasingOrStingDuration, transitionDirectionOrOverlay), seek: seek, length: length, filter: filter, channelLayout, clearOn404 }));
    }
    play(channel, layer = NaN, clip, loop, transition, transitionDurationOrMaskFileOrStingProps, transitionEasingOrStingDuration, transitionDirectionOrOverlay, seek, length, filter, channelLayout, clearOn404) {
        return this.do(new AMCP_1.AMCP.PlayCommand({ channel, layer, clip, loop, transition, ...this._createTransitionOptionsObject(transition, transitionDurationOrMaskFileOrStingProps, transitionEasingOrStingDuration, transitionDirectionOrOverlay), seek, length, filter, channelLayout, clearOn404 }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#LOADBG>
     */
    loadDecklinkBg(channel, layer = NaN, device, transition, transitionDurationOrMaskFile, transitionEasingOrStingDuration, transitionDirectionOrOverlay, length, filter, format, channelLayout, auto) {
        return this.do(new AMCP_1.AMCP.LoadDecklinkBgCommand({ channel: channel, layer: layer, device: device, transition: transition, ...this._createTransitionOptionsObject(transition, transitionDurationOrMaskFile, transitionEasingOrStingDuration, transitionDirectionOrOverlay), length: length, filter: filter, format: format, channelLayout: channelLayout, auto: auto }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#LOADBG>
     */
    loadDecklinkBgAuto(channel, layer = NaN, device, transition, transitionDurationOrMaskFile, transitionEasingOrStingDuration, transitionDirectionOrOverlay, length, filter, format, channelLayout) {
        return this.do(new AMCP_1.AMCP.LoadDecklinkBgCommand({ channel: channel, layer: layer, device: device, transition: transition, ...this._createTransitionOptionsObject(transition, transitionDurationOrMaskFile, transitionEasingOrStingDuration, transitionDirectionOrOverlay), length: length, filter: filter, format: format, channelLayout: channelLayout, auto: true }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#LOAD>
     */
    loadDecklink(channel, layer = NaN, device, transition, transitionDurationOrMaskFile, transitionEasingOrStingDuration, transitionDirectionOrOverlay, length, filter, format, channelLayout) {
        return this.do(new AMCP_1.AMCP.LoadDecklinkCommand({ channel: channel, layer: layer, device: device, transition: transition, ...this._createTransitionOptionsObject(transition, transitionDurationOrMaskFile, transitionEasingOrStingDuration, transitionDirectionOrOverlay), length: length, filter: filter, format: format, channelLayout: channelLayout }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#PLAY>
     */
    playDecklink(channel, layer = NaN, device, transition, transitionDurationOrMaskFile, transitionEasingOrStingDuration, transitionDirectionOrOverlay, length, filter, format, channelLayout) {
        return this.do(new AMCP_1.AMCP.PlayDecklinkCommand({ channel: channel, layer: layer, device: device, transition: transition, ...this._createTransitionOptionsObject(transition, transitionDurationOrMaskFile, transitionEasingOrStingDuration, transitionDirectionOrOverlay), length: length, filter: filter, format: format, channelLayout: channelLayout }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#LOADBG>
     */
    loadRouteBg(channel, layer = NaN, route, mode, transition, transitionDurationOrMaskFile, transitionEasingOrStingDuration, transitionDirectionOrOverlay, length, filter, format, channelLayout, auto, framesDelay) {
        return this.do(new AMCP_1.AMCP.LoadRouteBgCommand({ channel, layer, route, mode, transition, ...this._createTransitionOptionsObject(transition, transitionDurationOrMaskFile, transitionEasingOrStingDuration, transitionDirectionOrOverlay), length: length, filter: filter, format: format, channelLayout: channelLayout, auto: auto, framesDelay }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#LOADBG>
     */
    loadRouteBgAuto(channel, layer = NaN, route, mode, transition, transitionDurationOrMaskFile, transitionEasingOrStingDuration, transitionDirectionOrOverlay, length, filter, format, channelLayout, framesDelay) {
        return this.do(new AMCP_1.AMCP.LoadRouteBgCommand({ channel, layer, route, mode, transition, ...this._createTransitionOptionsObject(transition, transitionDurationOrMaskFile, transitionEasingOrStingDuration, transitionDirectionOrOverlay), length: length, filter: filter, format: format, channelLayout: channelLayout, auto: true, framesDelay }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#LOAD>
     */
    loadRoute(channel, layer = NaN, route, mode, transition, transitionDurationOrMaskFile, transitionEasingOrStingDuration, transitionDirectionOrOverlay, length, filter, format, channelLayout, framesDelay) {
        return this.do(new AMCP_1.AMCP.LoadRouteCommand({ channel, layer, route, mode, transition, ...this._createTransitionOptionsObject(transition, transitionDurationOrMaskFile, transitionEasingOrStingDuration, transitionDirectionOrOverlay), length: length, filter: filter, format: format, channelLayout: channelLayout, framesDelay }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#PLAY>
     */
    playRoute(channel, layer = NaN, route, mode, transition, transitionDurationOrMaskFile, transitionEasingOrStingDuration, transitionDirectionOrOverlay, length, filter, format, channelLayout, framesDelay) {
        return this.do(new AMCP_1.AMCP.PlayRouteCommand({ channel, layer, route, mode, transition, ...this._createTransitionOptionsObject(transition, transitionDurationOrMaskFile, transitionEasingOrStingDuration, transitionDirectionOrOverlay), length: length, filter: filter, format: format, channelLayout: channelLayout, framesDelay }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#LOADBG>
     */
    loadHtmlPageBg(channel, layer = NaN, clip, transition, transitionDurationOrMaskFile, transitionEasingOrStingDuration, transitionDirectionOrOverlay, auto) {
        return this.do(new AMCP_1.AMCP.LoadHtmlPageBgCommand({ channel: channel, layer: layer, clip: clip, transition: transition, ...this._createTransitionOptionsObject(transition, transitionDurationOrMaskFile, transitionEasingOrStingDuration, transitionDirectionOrOverlay), auto: auto }));
    }
    /**
     *
     */
    loadHtmlPageBgAuto(channel, layer = NaN, url, transition, transitionDurationOrMaskFile, transitionEasingOrStingDuration, transitionDirectionOrOverlay) {
        return this.do(new AMCP_1.AMCP.LoadHtmlPageBgCommand({ channel: channel, layer: layer, url: url, transition: transition, ...this._createTransitionOptionsObject(transition, transitionDurationOrMaskFile, transitionEasingOrStingDuration, transitionDirectionOrOverlay), auto: true }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#LOAD>
     */
    loadHtmlPage(channel, layer = NaN, url, transition, transitionDurationOrMaskFile, transitionEasingOrStingDuration, transitionDirectionOrOverlay) {
        return this.do(new AMCP_1.AMCP.LoadHtmlPageCommand({ channel: channel, layer: layer, url: url, transition: transition, ...this._createTransitionOptionsObject(transition, transitionDurationOrMaskFile, transitionEasingOrStingDuration, transitionDirectionOrOverlay) }));
    }
    playHtmlPage(channel, layer = NaN, url, transition, transitionDurationOrMaskFile, transitionEasingOrStingDuration, transitionDirectionOrOverlay) {
        return this.do(new AMCP_1.AMCP.PlayHtmlPageCommand({ channel: channel, layer: layer, url: url, transition: transition, ...this._createTransitionOptionsObject(transition, transitionDurationOrMaskFile, transitionEasingOrStingDuration, transitionDirectionOrOverlay) }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#PAUSE>
     */
    pause(channel, layer) {
        return this.do(new AMCP_1.AMCP.PauseCommand({ channel: channel, layer: layer }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#RESUME>
     */
    resume(channel, layer) {
        return this.do(new AMCP_1.AMCP.ResumeCommand({ channel: channel, layer: layer }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#STOP>
     */
    stop(channel, layer) {
        return this.do(new AMCP_1.AMCP.StopCommand({ channel: channel, layer: layer }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#CG-ADD>
     */
    cgAdd(channel, layer = NaN, flashLayer = NaN, templateName, playOnLoad, data) {
        return this.do(new AMCP_1.AMCP.CGAddCommand({ channel: channel, layer: layer, flashLayer: flashLayer, templateName: templateName, playOnLoad: playOnLoad, data: data }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#CG-PLAY>
     */
    cgPlay(channel, layer, flashLayer) {
        return this.do(new AMCP_1.AMCP.CGPlayCommand({ channel: channel, layer: layer, flashLayer: flashLayer }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#CG-STOP>
     */
    cgStop(channel, layer, flashLayer) {
        return this.do(new AMCP_1.AMCP.CGStopCommand({ channel: channel, layer: layer, flashLayer: flashLayer }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#CG-NEXT>
     */
    cgNext(channel, layer, flashLayer) {
        return this.do(new AMCP_1.AMCP.CGNextCommand({ channel: channel, layer: layer, flashLayer: flashLayer }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#CG-REMOVE>
     */
    cgRemove(channel, layer, flashLayer) {
        return this.do(new AMCP_1.AMCP.CGRemoveCommand({ channel: channel, layer: layer, flashLayer: flashLayer }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#CG-CLEAR>
     */
    cgClear(channel, layer) {
        return this.do(new AMCP_1.AMCP.CGClearCommand({ channel: channel, layer: layer }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#CG-UPDATE>
     */
    cgUpdate(channel, layer = NaN, flashLayer, data) {
        return this.do(new AMCP_1.AMCP.CGUpdateCommand({ channel: channel, layer: layer, flashLayer: flashLayer, data: data }));
    }
    /*
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#CG-INVOKE
     */
    cgInvoke(channel, layer, flashLayer, method) {
        return this.do(new AMCP_1.AMCP.CGInvokeCommand({ channel: channel, layer: layer, flashLayer: flashLayer, method: method }));
    }
    mixerKeyer(channel, layer, state, defer) {
        return this.do(new AMCP_1.AMCP.MixerKeyerCommand({ channel: channel, layer: layer, keyer: state, defer: defer }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#MIXER-KEYER>
     */
    mixerKeyerDeferred(channel, layer, state) {
        return this.mixerKeyer(channel, layer, state, true);
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#MIXER-KEYER>
     */
    getMixerStatusKeyer(channel, layer) {
        return this.do(new AMCP_1.AMCP.MixerStatusKeyerCommand({ channel: channel, layer: layer }));
    }
    mixerChroma(channel, layer = 0, keyer, threshold, softness, spill, transitionDuration, transitionEasing, defer) {
        return this.do(new AMCP_1.AMCP.MixerChromaCommand({ channel: channel, layer: layer, keyer: keyer, threshold: threshold, softness: softness, spill: spill, transitionDuration: transitionDuration, transitionEasing: transitionEasing, defer: defer }));
    }
    mixerChromaDeferred(channel, layer = 0, keyer, threshold, softness, spill, transitionDuration, transitionEasing) {
        return this.mixerChroma(channel, layer, keyer, threshold, softness, spill, transitionDuration, transitionEasing, true);
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#MIXER-CHROMA>
     */
    getMixerStatusChroma(channel, layer) {
        return this.do(new AMCP_1.AMCP.MixerStatusChromaCommand({ channel: channel, layer: layer }));
    }
    mixerBlend(channel, layer, blendmode, defer) {
        return this.do(new AMCP_1.AMCP.MixerBlendCommand({ channel: channel, layer: layer, blendmode: blendmode, defer: defer }));
    }
    mixerBlendDeferred(channel, layer = NaN, blendmode) {
        return this.mixerBlend(channel, layer, blendmode, true);
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#MIXER-BLEND>
     */
    getMixerStatusBlend(channel, layer) {
        return this.do(new AMCP_1.AMCP.MixerStatusBlendCommand({ channel: channel, layer: layer }));
    }
    mixerOpacity(channel, layer, opacity, transitionDuration, transitionEasing, defer) {
        return this.do(new AMCP_1.AMCP.MixerOpacityCommand({ channel: channel, layer: layer, opacity: opacity, transitionDuration: transitionDuration, transitionEasing: transitionEasing, defer: defer }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#MIXER-OPACITY>
     */
    mixerOpacityDeferred(channel, layer = NaN, opacity, transitionDuration, transitionEasing) {
        return this.mixerOpacity(channel, layer, opacity, transitionDuration, transitionEasing, true);
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#MIXER-OPACITY>
     */
    getMixerStatusOpacity(channel, layer) {
        return this.do(new AMCP_1.AMCP.MixerStatusOpacityCommand({ channel: channel, layer: layer }));
    }
    mixerBrightness(channel, layer, brightness, transitionDuration, transitionEasing, defer) {
        return this.do(new AMCP_1.AMCP.MixerBrightnessCommand({ channel: channel, layer: layer, brightness: brightness, transitionDuration: transitionDuration, transitionEasing: transitionEasing, defer: defer }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#MIXER-BRIGHTNESS>
     */
    mixerBrightnessDeferred(channel, layer = NaN, brightness, transitionDuration, transitionEasing) {
        return this.mixerBrightness(channel, layer, brightness, transitionDuration, transitionEasing, true);
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#MIXER-BRIGHTNESS>
     */
    getMixerStatusBrightness(channel, layer) {
        return this.do(new AMCP_1.AMCP.MixerStatusBrightnessCommand({ channel: channel, layer: layer }));
    }
    mixerSaturation(channel, layer, saturation, transitionDuration, transitionEasing, defer) {
        return this.do(new AMCP_1.AMCP.MixerSaturationCommand({ channel: channel, layer: layer, saturation: saturation, transitionDuration: transitionDuration, transitionEasing: transitionEasing, defer: defer }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#MIXER-SATURATION>
     */
    mixerSaturationDeferred(channel, layer = NaN, saturation, transitionDuration, transitionEasing) {
        return this.mixerSaturation(channel, layer, saturation, transitionDuration, transitionEasing, true);
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#MIXER-SATURATION>
     */
    getMixerStatusSaturation(channel, layer) {
        return this.do(new AMCP_1.AMCP.MixerStatusSaturationCommand({ channel: channel, layer: layer }));
    }
    mixerContrast(channel, layer, contrast, transitionDuration, transitionEasing, defer) {
        return this.do(new AMCP_1.AMCP.MixerContrastCommand({ channel: channel, layer: layer, contrast: contrast, transitionDuration: transitionDuration, transitionEasing: transitionEasing, defer: defer }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#MIXER-CONTRAST>
     */
    mixerContrastDeferred(channel, layer = NaN, contrast, transitionDuration, transitionEasing) {
        return this.mixerContrast(channel, layer, contrast, transitionDuration, transitionEasing, true);
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#MIXER-CONTRAST>
     */
    getMixerStatusContrast(channel, layer) {
        return this.do(new AMCP_1.AMCP.MixerStatusContrastCommand({ channel: channel, layer: layer }));
    }
    mixerLevels(channel, layer = NaN, minInput, maxInput, gamma, minOutput, maxOutput, transitionDuration, transitionEasing, defer) {
        return this.do(new AMCP_1.AMCP.MixerLevelsCommand({ channel: channel, layer: layer, minInput: minInput, maxInput: maxInput, gamma: gamma, minOutput: minOutput, maxOutput: maxOutput, transitionDuration: transitionDuration, transitionEasing: transitionEasing, defer: defer }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#MIXER-LEVELS>
     */
    mixerLevelsDeferred(channel, layer = NaN, minInput, maxInput, gamma, minOutput, maxOutput, transitionDuration, transitionEasing) {
        return this.mixerLevels(channel, layer, minInput, maxInput, gamma, minOutput, maxOutput, transitionDuration, transitionEasing, true);
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#MIXER-LEVELS>
     */
    getMixerStatusLevels(channel, layer) {
        return this.do(new AMCP_1.AMCP.MixerStatusLevelsCommand({ channel: channel, layer: layer }));
    }
    mixerFill(channel, layer = NaN, x, y, xScale, yScale, transitionDuration, transitionEasing, defer) {
        return this.do(new AMCP_1.AMCP.MixerFillCommand({ channel: channel, layer: layer, x: x, y: y, xScale: xScale, yScale: yScale, transitionDuration: transitionDuration, transitionEasing: transitionEasing, defer: defer }));
    }
    /*
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#MIXER-FILL>
     */
    mixerFillDeferred(channel, layer = NaN, x, y, xScale, yScale, transitionDuration, transitionEasing) {
        return this.mixerFill(channel, layer, x, y, xScale, yScale, transitionDuration, transitionEasing, true);
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#MIXER-FILL>
     */
    getMixerStatusFill(channel, layer) {
        return this.do(new AMCP_1.AMCP.MixerStatusFillCommand({ channel: channel, layer: layer }));
    }
    mixerClip(channel, layer = NaN, x, y, width, height, transitionDuration, transitionEasing, defer) {
        return this.do(new AMCP_1.AMCP.MixerClipCommand({ channel: channel, layer: layer, x: x, y: y, width: width, height: height, transitionDuration: transitionDuration, transitionEasing: transitionEasing, defer: defer }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#MIXER-CLIP>
     */
    mixerClipDeferred(channel, layer = NaN, x, y, width, height, transitionDuration, transitionEasing) {
        return this.mixerClip(channel, layer, x, y, width, height, transitionDuration, transitionEasing, true);
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#MIXER-CLIP>
     */
    getMixerStatusClip(channel, layer) {
        return this.do(new AMCP_1.AMCP.MixerStatusClipCommand({ channel: channel, layer: layer }));
    }
    mixerAnchor(channel, layer = NaN, x, y, transitionDuration, transitionEasing, defer) {
        return this.do(new AMCP_1.AMCP.MixerAnchorCommand({ channel: channel, layer: layer, x: x, y: y, ransition: transitionDuration, transitionEasing: transitionEasing, defer: defer }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#MIXER-ANCHOR>
     */
    mixerAnchorDeferred(channel, layer = NaN, x, y, transitionDuration, transitionEasing) {
        return this.mixerAnchor(channel, layer, x, y, transitionDuration, transitionEasing, true);
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#MIXER-ANCHOR>
     */
    getMixerStatusAnchor(channel, layer) {
        return this.do(new AMCP_1.AMCP.MixerStatusAnchorCommand({ channel: channel, layer: layer }));
    }
    mixerCrop(channel, layer = NaN, left, top, right, bottom, transitionDuration, transitionEasing, defer) {
        return this.do(new AMCP_1.AMCP.MixerCropCommand({ channel: channel, layer: layer, left: left, top: top, right: right, bottom: bottom, transitionDuration: transitionDuration, transitionEasing: transitionEasing, defer: defer }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#MIXER-CROP>
     */
    mixerCropDeferred(channel, layer = NaN, left, top, right, bottom, transitionDuration, transitionEasing) {
        return this.mixerCrop(channel, layer, left, top, right, bottom, transitionDuration, transitionEasing, true);
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#MIXER-CROP>
     */
    getMixerStatusCrop(channel, layer) {
        return this.do(new AMCP_1.AMCP.MixerStatusCropCommand({ channel: channel, layer: layer }));
    }
    mixerRotation(channel, layer, rotation, transitionDuration, transitionEasing, defer) {
        return this.do(new AMCP_1.AMCP.MixerRotationCommand({ channel: channel, layer: layer, rotation: rotation, transitionDuration: transitionDuration, transitionEasing: transitionEasing, defer: defer }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#MIXER-ROTATION>
     */
    mixerRotationDeferred(channel, layer = NaN, rotation, transitionDuration, transitionEasing) {
        return this.mixerRotation(channel, layer, rotation, transitionDuration, transitionEasing, true);
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#MIXER-ROTATION>
     */
    getMixerStatusRotation(channel, layer) {
        return this.do(new AMCP_1.AMCP.MixerStatusRotationCommand({ channel: channel, layer: layer }));
    }
    mixerPerspective(channel, layer = NaN, topLeftX, topLeftY, topRightX, topRightY, bottomRightX, bottomRightY, bottomLeftX, bottomLeftY, transitionDuration, transitionEasing, defer) {
        return this.do(new AMCP_1.AMCP.MixerPerspectiveCommand({ channel: channel, layer: layer, topLeftX: topLeftX, topLeftY: topLeftY, topRightX: topRightX, topRightY: topRightY, bottomRightX: bottomRightX, bottomRightY: bottomRightY, bottomLeftX: bottomLeftX, bottomLeftY: bottomLeftY, transitionDuration: transitionDuration, transitionEasing: transitionEasing, defer: defer }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#MIXER-PERSPECTIVE>
     */
    mixerPerspectiveDeferred(channel, layer = NaN, topLeftX, topLeftY, topRightX, topRightY, bottomRightX, bottomRightY, bottomLeftX, bottomLeftY, transitionDuration, transitionEasing) {
        return this.mixerPerspective(channel, layer, topLeftX, topLeftY, topRightX, topRightY, bottomRightX, bottomRightY, bottomLeftX, bottomLeftY, transitionDuration, transitionEasing, true);
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#MIXER-PERSPECTIVE>
     */
    getMixerStatusPerspective(channel, layer) {
        return this.do(new AMCP_1.AMCP.MixerStatusPerspectiveCommand({ channel: channel, layer: layer }));
    }
    mixerMipmap(channel, layer, state, defer) {
        return this.do(new AMCP_1.AMCP.MixerMipmapCommand({ channel: channel, layer: layer, keyer: state, defer: defer }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#MIXER-MIPMAP>
     */
    mixerMipmapDeferred(channel, layer, state) {
        return this.mixerMipmap(channel, layer, state, true);
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#MIXER-MIPMAP>
     */
    getMixerStatusMipmap(channel, layer) {
        return this.do(new AMCP_1.AMCP.MixerStatusMipmapCommand({ channel: channel, layer: layer }));
    }
    mixerVolume(channel, layer, volume, transitionDuration, transitionEasing, defer) {
        return this.do(new AMCP_1.AMCP.MixerVolumeCommand({ channel: channel, layer: layer, volume: volume, transitionDuration: transitionDuration, transitionEasing: transitionEasing, defer: defer }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#MIXER-VOLUME>
     */
    mixerVolumeDeferred(channel, layer = NaN, volume, transitionDuration, transitionEasing) {
        return this.mixerVolume(channel, layer, volume, transitionDuration, transitionEasing, true);
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#MIXER-VOLUME>
     */
    getMixerStatusVolume(channel, layer) {
        return this.do(new AMCP_1.AMCP.MixerStatusVolumeCommand({ channel: channel, layer: layer }));
    }
    mixerMastervolume(channel, mastervolume, defer) {
        return this.do(new AMCP_1.AMCP.MixerMastervolumeCommand({ channel: channel, mastervolume: mastervolume, defer: defer }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#MIXER-MASTERVOLUME>
     */
    mixerMastervolumeDeferred(channel, mastervolume) {
        return this.mixerMastervolume(channel, mastervolume, true);
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#MIXER-MASTERVOLUME>
     */
    getMixerStatusMastervolume(channel) {
        return this.do(new AMCP_1.AMCP.MixerStatusMastervolumeCommand({ channel: channel }));
    }
    mixerStraightAlphaOutput(channel, layer, state, defer) {
        return this.do(new AMCP_1.AMCP.MixerKeyerCommand({ channel: channel, layer: layer, keyer: state, defer: defer }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#MIXER-STRAIGHT_ALPHA_OUTPUT>
     */
    mixerStraightAlphaOutputDeferred(channel, layer, state) {
        return this.mixerStraightAlphaOutput(channel, layer, state, true);
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#MIXER-STRAIGHT_ALPHA_OUTPUT>
     */
    getMixerStatusStraightAlphaOutput(channel, layer) {
        return this.do(new AMCP_1.AMCP.MixerStatusStraightAlphaOutputCommand({ channel: channel, layer: layer }));
    }
    mixerGrid(channel, resolution, transitionDuration, transitionEasing, defer) {
        return this.do(new AMCP_1.AMCP.MixerGridCommand({ channel: channel, resolution: resolution, transitionDuration: transitionDuration, transitionEasing: transitionEasing, defer: defer }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#MIXER-GRID>
     */
    mixerGridDeferred(channel, resolution, transitionDuration, transitionEasing) {
        return this.mixerGrid(channel, resolution, transitionDuration, transitionEasing, true);
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#MIXER-COMMIT>
     */
    mixerCommit(channel) {
        return this.do(new AMCP_1.AMCP.MixerCommitCommand({ channel: channel }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#MIXER-CLEAR>
     */
    mixerClear(channel, layer) {
        return this.do(new AMCP_1.AMCP.MixerClearCommand({ channel: channel, layer: layer }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#CLEAR>
     */
    clear(channel, layer) {
        return this.do(new AMCP_1.AMCP.ClearCommand({ channel: channel, layer: layer }));
    }
    /**
     * @todo	implement
     * @todo	document
     */
    call(channel, layer) {
        return this.do(new AMCP_1.AMCP.CallCommand({ channel: channel, layer: layer }));
    }
    /**
     * @todo	implement
     * @todo	document
     */
    swap() {
        // @todo: overloading of origin/destination pairs
        return this.do(new AMCP_1.AMCP.SwapCommand());
    }
    /**
     * @todo	implement
     * @todo	document
     */
    add(channel) {
        // remember index /layer
        // i suggest duplicating abstractchannelorlayer to avoid problems if the address logic changes for layers and not indicies
        // consumer factoruies parses "consumer"-string parameter
        return this.do(new AMCP_1.AMCP.AddCommand({ channel: channel }));
    }
    /**
     *  <https://github.com/CasparCG/help/wiki/AMCP-Protocol#ADD>
     */
    addDecklink(channel, device, id) {
        return this.do(new AMCP_1.AMCP.AddDecklinkCommand({ channel: channel, layer: id, device: device }));
    }
    /**
     *  <https://github.com/CasparCG/help/wiki/AMCP-Protocol#ADD>
     */
    addImage(channel, fileName, id) {
        return this.do(new AMCP_1.AMCP.AddImageCommand({ channel: channel, layer: id, fileName: fileName }));
    }
    /**
     *  <https://github.com/CasparCG/help/wiki/AMCP-Protocol#ADD>
     */
    addFile(channel, fileName, id) {
        return this.do(new AMCP_1.AMCP.AddFileCommand({ channel: channel, layer: id, fileName: fileName }));
    }
    /**
     *  <https://github.com/CasparCG/help/wiki/AMCP-Protocol#ADD>
     */
    addStream(channel, uri, params, id) {
        return this.do(new AMCP_1.AMCP.AddStreamCommand({ channel: channel, layer: id, uri: uri, params: params }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#REMOVE>
     */
    remove(channel, id) {
        return this.do(new AMCP_1.AMCP.RemoveCommand({ channel: channel, layer: id }));
    }
    /**
     *  <https://github.com/CasparCG/help/wiki/AMCP-Protocol#REMOVE>
     */
    removeDecklink(channel, device) {
        return this.do(new AMCP_1.AMCP.RemoveDecklinkCommand({ channel: channel, device: device }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#REMOVE>
     */
    removeImage(channel, fileName) {
        return this.do(new AMCP_1.AMCP.RemoveImageCommand({ channel: channel, fileName: fileName }));
    }
    /**
     *  <https://github.com/CasparCG/help/wiki/AMCP-Protocol#REMOVE>
     */
    removeFile(channel, fileName) {
        return this.do(new AMCP_1.AMCP.RemoveFileCommand({ channel: channel, fileName: fileName }));
    }
    /**
     *  <https://github.com/CasparCG/help/wiki/AMCP-Protocol#REMOVE>
     */
    removeStream(channel, uri) {
        return this.do(new AMCP_1.AMCP.RemoveStreamCommand({ channel: channel, uri: uri }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#PRINT>
     */
    print(channel) {
        return this.do(new AMCP_1.AMCP.PrintCommand({ channel: channel }));
    }
    /**
     * @todo	implement
     * @todo	document
     */
    set(channel) {
        // @todo:  param enum (only MODE and channelLayout for now)
        // @todo: switchable second parameter based on what to set:
        // mode = enum modes.......
        // layer = enum layouts..........
        return this.do(new AMCP_1.AMCP.SetCommand({ channel: channel }));
    }
    lock(channel, action, lockPhrase) {
        return this.do(new AMCP_1.AMCP.LockCommand({ channel: channel, action: action, phrase: lockPhrase }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#CHANNEL-GRID>
     */
    channelGrid() {
        return this.do(new AMCP_1.AMCP.ChannelGridCommand());
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#GL-GC>
     */
    glGC() {
        return this.do(new AMCP_1.AMCP.GlGCCommand());
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#DATA-STORE>
     */
    dataStore(fileName, data) {
        return this.do(new AMCP_1.AMCP.DataStoreCommand({ fileName: fileName, data: data }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#DATA-RETRIEVE>
     */
    dataRetrieve(fileName) {
        return this.do(new AMCP_1.AMCP.DataRetrieveCommand({ fileName: fileName }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#DATA-LIST>
     */
    dataList() {
        return this.do(new AMCP_1.AMCP.DataListCommand());
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#DATA-REMOVE>
     */
    dataRemove(fileName) {
        return this.do(new AMCP_1.AMCP.DataRemoveCommand({ fileName: fileName }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#THUMBNAIL-LIST>
     */
    thumbnailList(subFolder) {
        return this.do(new AMCP_1.AMCP.ThumbnailListCommand({ subFolder: subFolder }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#THUMBNAIL-RETRIEVE>
     */
    thumbnailRetrieve(fileName) {
        return this.do(new AMCP_1.AMCP.ThumbnailRetrieveCommand({ fileName: fileName }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#THUMBNAIL-GENERATE>
     */
    thumbnailGenerate(fileName) {
        return this.do(new AMCP_1.AMCP.ThumbnailGenerateCommand({ fileName: fileName }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#THUMBNAIL-GENERATE_ALL>
     */
    thumbnailGenerateAll() {
        return this.do(new AMCP_1.AMCP.ThumbnailGenerateAllCommand());
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#CINF>
     */
    cinf(fileName) {
        return this.do(new AMCP_1.AMCP.CinfCommand({ fileName: fileName }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#CLS>
     */
    cls(subFolder) {
        return this.do(new AMCP_1.AMCP.ClsCommand({ subFolder: subFolder }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#FLS>
     */
    fls() {
        return this.do(new AMCP_1.AMCP.FlsCommand());
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#TLS>
     */
    tls(subFolder) {
        return this.do(new AMCP_1.AMCP.TlsCommand({ subFolder: subFolder }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#VERSION>
     */
    version(component) {
        return this.do(new AMCP_1.AMCP.VersionCommand({ component: component }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#INFO>
     */
    info(channel, layer) {
        return this.do(new AMCP_1.AMCP.InfoCommand({ channel: channel, layer: layer }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#INFO-TEMPLATE>
     */
    infoTemplate(template) {
        return this.do(new AMCP_1.AMCP.InfoTemplateCommand({ template: template }));
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#INFO-CONFIG>
     */
    infoConfig() {
        return new Promise((resolve, reject) => {
            this.getCasparCGVersion().then((version) => {
                resolve(this.do(new AMCP_1.AMCP.InfoConfigCommand([], { serverVersion: version })));
            }).catch(reject);
        });
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#INFO-PATHS>
     */
    infoPaths() {
        return this.do(new AMCP_1.AMCP.InfoPathsCommand());
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#INFO-SYSTEM>
     */
    infoSystem() {
        return this.do(new AMCP_1.AMCP.InfoSystemCommand());
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#INFO-SERVER>
     */
    infoServer() {
        return this.do(new AMCP_1.AMCP.InfoServerCommand());
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#INFO-QUEUES>
     */
    infoQueues() {
        return this.do(new AMCP_1.AMCP.InfoQueuesCommand());
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#INFO-THREADS>
     */
    infoThreads() {
        return this.do(new AMCP_1.AMCP.InfoThreadsCommand());
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#INFO-DELAY>
     */
    infoDelay(channel, layer) {
        return this.do(new AMCP_1.AMCP.InfoDelayCommand({ channel: channel, layer: layer }));
    }
    /**
     * Retrieves information about a running template or the templatehost.
     *
     * Calling `infoDelay` without `flashLayer` parameter is the same as calling the convenience method [[templateHostInfo]].
     *
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#CG-INFO>
     *
     * @param flashLayer	If not specified, information about the `TemplateHost` will be returned.
     */
    cgInfo(channel, layer, flashLayer) {
        return this.do(new AMCP_1.AMCP.CGInfoCommand({ channel: channel, layer: layer, flashLayer: flashLayer }));
    }
    /**
     * Convenience method for calling [[cgInfo]] to return information about `TemplateHost` for a given layer.
     *
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#CG-INFO>
     */
    templateHostInfo(channel, layer) {
        return this.cgInfo(channel, layer);
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#GL-INFO>
     */
    glInfo() {
        return this.do(new AMCP_1.AMCP.GlInfoCommand());
    }
    /**
     * Sets the server's [[LogLevel]].
     *
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#LOG-LEVEL>
     */
    logLevel(enumOrString) {
        return this.do(new AMCP_1.AMCP.LogLevelCommand({ level: enumOrString }));
    }
    /**
     * Enabling or disabling logging for a given [[LogCategory]].
     *
     * Convenience methods [[logCalltrace]] and [[logCommunication]] are available.
     *
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#LOG_CATEGORY>
     */
    logCategory(category, enabled) {
        let params = {};
        params[category.toString().toLowerCase()] = enabled;
        return this.do(new AMCP_1.AMCP.LogCategoryCommand(params));
    }
    /**
     * Convenience method for enabling or disabling logging for [[LogCategory.CALLTRACE]] through calling [[logCategory]].
     */
    logCalltrace(enabled) {
        return this.logCategory(ServerStateEnum_1.Enum.LogCategory.CALLTRACE, enabled);
    }
    /**
     * Convenience method for enabling or disabling logging for [[LogCategory.COMMUNICATION]] through calling [[logCategory]].
     */
    logCommunication(enabled) {
        return this.logCategory(ServerStateEnum_1.Enum.LogCategory.COMMUNICATION, enabled);
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#DIAG>
     */
    diag() {
        return this.do(new AMCP_1.AMCP.DiagCommand());
    }
    help(commandOrName) {
        let param = {};
        if (commandOrName) {
            param['command'] = commandOrName;
        }
        return this.do(new AMCP_1.AMCP.HelpCommand(param));
    }
    /**
     * Convenience method for calling [[help]] with no parameters.
     *
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#HELP>
     */
    getCommands() {
        return this.help();
    }
    helpProducer(producerOrName) {
        let param = {};
        if (producerOrName) {
            param['producer'] = producerOrName;
        }
        return this.do(new AMCP_1.AMCP.HelpProducerCommand(param));
    }
    /**
     * Convenience method for calling [[helpProducer]] with no parameters.
     *
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#HELP-PRODUCER>
     */
    getProducers() {
        return this.helpProducer();
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#HELP-CONSUMER>
     */
    helpConsumer(consumerOrName) {
        let param = {};
        if (consumerOrName) {
            param['consumer'] = consumerOrName;
        }
        return this.do(new AMCP_1.AMCP.HelpConsumerCommand(param));
    }
    /**
     * Convenience method for calling [[helpConsumer]] with no parameters.
     *
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#HELP-CONSUMER>
     */
    getConsumers() {
        return this.helpConsumer();
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#BYE>
     */
    bye() {
        return this.do(new AMCP_1.AMCP.ByeCommand());
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#KILL>
     */
    kill() {
        return this.do(new AMCP_1.AMCP.KillCommand());
    }
    /**
     * <https://github.com/CasparCG/help/wiki/AMCP-Protocol#RESTART>
     */
    restart() {
        return this.do(new AMCP_1.AMCP.RestartCommand());
    }
    /**
     * Undocumented, but implemented by Julusian.
     */
    ping() {
        return this.do(new AMCP_1.AMCP.PingCommand());
    }
    /**
     * Undocumented, but implemented by Julusian.
     */
    time(channel, timecode) {
        return this.do(new AMCP_1.AMCP.TimeCommand({ channel, timecode }));
    }
    /**
     * https://github.com/CasparCG/server/issues/872
     */
    scheduleSet(timecode, command) {
        return this.do(new AMCP_1.AMCP.ScheduleSetCommand({ token: command.token, timecode, command }));
    }
    /**
     * https://github.com/CasparCG/server/issues/872
     */
    scheduleRemove(token) {
        return this.do(new AMCP_1.AMCP.ScheduleRemoveCommand({ token }));
    }
    /**
     * https://github.com/CasparCG/server/issues/872
     */
    scheduleClear() {
        return this.do(new AMCP_1.AMCP.ScheduleClearCommand());
    }
    /**
     * https://github.com/CasparCG/server/issues/872
     */
    scheduleList(timecode) {
        return this.do(new AMCP_1.AMCP.ScheduleListCommand({ timecode }));
    }
    /**
     * Automatically create a transition object with the correct transition keys
     */
    _createTransitionOptionsObject(transition, transitionDurationOrMaskFileOrProps, transitionEasingOrStingDuration, transitionDirectionOrOverlay) {
        if (transition === ServerStateEnum_1.Enum.Transition.STING.toString()) {
            if (typeof transitionDurationOrMaskFileOrProps === 'object') {
                return {
                    stingTransitionProperties: {
                        ...transitionDurationOrMaskFileOrProps
                    }
                };
            }
            else {
                return {
                    stingMaskFilename: transitionDurationOrMaskFileOrProps,
                    stingDelay: transitionEasingOrStingDuration,
                    stingOverlayFilename: transitionDirectionOrOverlay || ''
                };
            }
        }
        else {
            return {
                transitionDuration: transitionDurationOrMaskFileOrProps,
                transitionEasing: transitionEasingOrStingDuration,
                transitionDirection: transitionDirectionOrOverlay
            };
        }
    }
    /**
     *
     */
    _createNewSocket(options, enforceRecreation = false) {
        let hasNewOptions = false;
        if (options) {
            for (let key in options) {
                if (!options.hasOwnProperty(key)) {
                    continue;
                }
                if (this.hasOwnProperty(key) || CasparCG.prototype.hasOwnProperty(key)) {
                    // only update new options
                    if (this[key] !== options[key]) {
                        this[key] = options[key];
                        hasNewOptions = true;
                    }
                }
            }
        }
        // dont recreate if exising socket, same options + host + port
        if (this._socket && (this._socket.host !== this.host)) {
            hasNewOptions = true;
        }
        if (this._socket && (this._socket.port !== this.port)) {
            hasNewOptions = true;
        }
        if (this._socket && !hasNewOptions && !enforceRecreation) {
            return;
        }
        // clean up if existing socket
        if (this._socket) {
            this._socket.dispose();
            delete this._socket;
        }
        this._socket = new CasparCGSocket_1.CasparCGSocket(this.host, this.port, this.autoReconnect, this.autoReconnectInterval, this.autoReconnectAttempts, this.queueMode);
        this._socket.on('error', (error) => this._onSocketError(error));
        this._socket.on(Events_1.CasparCGSocketStatusEvent.STATUS, (event) => this._onSocketStatusChange(event));
        this._socket.on(Events_1.CasparCGSocketStatusEvent.TIMEOUT, () => this._onSocketStatusTimeout());
        this._socket.on(Events_1.CasparCGSocketResponseEvent.RESPONSE, (event) => this._handleSocketResponse(event.response));
        this._socket.on(Events_1.CasparCGSocketResponseEvent.INVALID_RESPONSE, () => this._handleInvalidSocketResponse());
        // inherit log method
        this._socket.log = (args) => this._log(args);
    }
    /**
     *
     */
    _fetchNextCommand() {
        let VO = null;
        if (this._queuedCommandsHighPriority.length > 0) {
            VO = { cmd: this._queuedCommandsHighPriority.shift(), priority: Priority.HIGH };
        }
        else if (this._queuedCommands.length > 0) {
            VO = { cmd: this._queuedCommands.shift(), priority: Priority.NORMAL };
        }
        else if (this._queuedCommandsLowPriority.length > 0) {
            VO = { cmd: this._queuedCommandsLowPriority.shift(), priority: Priority.LOW };
        }
        return VO;
    }
    /**
     *
     */
    get _nextCommand() {
        if (this._queuedCommandsHighPriority.length > 0) {
            return { cmd: this._queuedCommandsHighPriority[0], priority: Priority.HIGH };
        }
        else if (this._queuedCommands.length > 0) {
            return { cmd: this._queuedCommands[0], priority: Priority.NORMAL };
        }
        else if (this._queuedCommandsLowPriority.length > 0) {
            return { cmd: this._queuedCommandsLowPriority[0], priority: Priority.LOW };
        }
        else {
            return null;
        }
    }
    /**
     *
     */
    _onSocketError(error) {
        this._log(error); // gets emited through the log function
    }
    /**
     *
     */
    _log(args) {
        if (args instanceof Error) {
            if (this.listenerCount('error') > 0) {
                this.emit('error', args);
            }
            if (this.onError) {
                this.onError(args);
            }
        }
        else {
            if (this.debug) {
                console.log(args);
            }
            if (this.onLog) {
                this.onLog(args);
            }
            this.emit(Events_1.LogEvent.LOG, new Events_1.LogEvent(args));
        }
    }
    /**
     *
     */
    _onSocketStatusChange(socketStatus) {
        let connected = socketStatus.valueOf().connected === true;
        if (this.onConnectionStatus) {
            this.onConnectionStatus(socketStatus.valueOf());
        }
        if (connected !== this._connected) {
            if (connected) {
                // @todo: handle flush SENT-buffer + shift/push version command in queue. (add back the sent command (retry strategy)) + make sure VERSION comes first after reconnect
                this._flushSentCommands();
                // reset cached data
                delete this._configPromise;
                delete this._pathsPromise;
                delete this._versionPromise;
            }
            this._connected = connected;
            this.emit(Events_1.CasparCGSocketStatusEvent.STATUS_CHANGED, socketStatus);
            if (this.onConnectionChanged) {
                this.onConnectionChanged(this._connected);
            }
            if (this._connected) {
                this._executeNextCommand(); // gets going on commands already on queue, also cleans up sent command buffers
                // do checks to see if the server has been alive and used before this connection, or is in a untouched state
                if (this.virginServerCheck) {
                    this.doNow(new AMCP_1.AMCP.InfoCommand())
                        .then((info) => {
                        let channelPromises = [];
                        let channelLength = info.response.data.length;
                        for (let i = 1; i <= channelLength; i++) { // 1-based index for channels
                            channelPromises.push(this.doNow(new AMCP_1.AMCP.InfoCommand({ channel: i })));
                        }
                        let virgin = true;
                        return Promise.all(channelPromises).then((channels) => {
                            for (let i = 0; i < channels.length; i++) {
                                let channelInfo = channels[i];
                                if (channelInfo.response.data.stage) {
                                    virgin = false;
                                    break;
                                }
                            }
                            this.emit(Events_1.CasparCGSocketStatusEvent.CONNECTED, { connected: this._connected, virginServer: virgin });
                            if (this.onConnected) {
                                this.onConnected(this._connected);
                            }
                        });
                    })
                        .catch(() => {
                        this.emit(Events_1.CasparCGSocketStatusEvent.CONNECTED, socketStatus);
                        if (this.onConnected) {
                            this.onConnected(this._connected);
                        }
                    });
                    // don't check virgin state, just inform about the connection asap
                }
                else {
                    this.emit(Events_1.CasparCGSocketStatusEvent.CONNECTED, socketStatus);
                    if (this.onConnected) {
                        this.onConnected(this._connected);
                    }
                }
            }
            if (!this._connected) {
                this.emit(Events_1.CasparCGSocketStatusEvent.DISCONNECTED, socketStatus);
                if (this.onDisconnected) {
                    this.onDisconnected(this._connected);
                }
            }
        }
    }
    /**
     *
     */
    _onSocketStatusTimeout() {
        if (Object.keys(this._sentCommands).length > 0) {
            this._log(`Command timed out. Starting flush procedure, with ${Object.keys(this._sentCommands).length} command(s) in sentCommands.`);
        }
        // @todo: implement retry strategy #81
        // 1) discard
        // this._expediteCommand(true);
        // 2) retry (max attempts missing)
        this.reconnect();
        // 3) smart/probe
        // try to send INFO
        // -> SUCCESS
        // discard that single command, procees
        // -> FAIL
        // reconncet
    }
    /**
     *
     */
    _handleSocketResponse(socketResponse) {
        /*

        100 [action] - Information about an event.
        101 [action] - Information about an event. A line of data is being returned.

        200 [command] OK	- The command has been executed and several lines of data (seperated by \r\n) are being returned (terminated with an additional \r\n)
        201 [command] OK	- The command has been executed and data (terminated by \r\n) is being returned.
        202 [command] OK	- The command has been executed.

        400 ERROR	- Command not understood
        401 [command] ERROR	- Illegal video_channel
        402 [command] ERROR	- Parameter missing
        403 [command] ERROR	- Illegal parameter
        404 [command] ERROR	- Media file not found

        500 FAILED	- Internal server error
        501 [command] FAILED	- Internal server error
        502 [command] FAILED	- Media file unreadable

        */
        // receive data & handle possible timeout first
        // parse incoming data & handle parsing errors (response code unknown, unexpected format)
        // create error object for response codes 400 to 502
        // reject with error object
        // create response object for response codes 200 to 202
        // resolve with response object
        // handle unkown tokens:
        let currentCommand;
        if (socketResponse.token) {
            if (this._queueMode === QueueMode.SALVO && !this._sentCommands[socketResponse.token]) {
                this._log(`Received a response from an unknown command with token ${socketResponse.token}`);
                return;
            }
            currentCommand = this._sentCommands[socketResponse.token];
            delete this._sentCommands[socketResponse.token];
        }
        else {
            if (Object.keys(this._sentCommands).length === 0) {
                this._log(`Received a response without knowlingy having sent anyting.`);
                return;
            }
            let token = Object.keys(this._sentCommands)[0];
            currentCommand = (this._sentCommands[token]);
            delete this._sentCommands[token];
        }
        this._log(`Handling response, "${currentCommand.name}" with token "${currentCommand.token}"`);
        if (!(currentCommand.response instanceof AMCPResponse)) {
            currentCommand.response = new AMCPResponse();
        }
        if (currentCommand.validateResponse(socketResponse)) {
            if (currentCommand.name === 'ScheduleSetCommand') {
                let scheduledCommand = currentCommand.getParam('command');
                scheduledCommand.status = IAMCPStatus.Sent;
                this._sentCommands[scheduledCommand.token] = scheduledCommand;
                this._log(`New command scheduled, "${scheduledCommand.name}".`);
            }
            else if (currentCommand.name === 'ScheduleRemoveCommand') {
                delete this._sentCommands[currentCommand.getParam('token')];
            }
            currentCommand.status = IAMCPStatus.Suceeded;
            currentCommand.resolve(currentCommand);
        }
        else {
            currentCommand.status = IAMCPStatus.Failed;
            currentCommand.reject(currentCommand);
        }
        this.emit(Events_1.CasparCGSocketCommandEvent.RESPONSE, new Events_1.CasparCGSocketCommandEvent(currentCommand));
        this._executeNextCommand();
    }
    /**
     *
     */
    _handleInvalidSocketResponse() {
        // @todo: in the future, perhaps we could better predict that the connection is in a restart-state, and act accordingly, to
        // gracefully keep/fall back data and/or speed up reconnection??
    }
    /**
     *
     */
    _flushSentCommands() {
        for (let token in this._sentCommands) {
            let i = this._sentCommands[token];
            delete this._sentCommands[token];
            this._log(`Flushing commands from sent-queue. Deleting: "${i.name}" with token "${i.token}".`);
            i.status = IAMCPStatus.Failed;
            i.reject(i);
        }
    }
    /**
     *
     */
    _executeNextCommand() {
        if (this.connected) {
            if (this._queueMode === QueueMode.SALVO) {
                while (this.commandQueueLength > 0) {
                    let nextCommand = this._fetchNextCommand();
                    if (nextCommand) {
                        this._sentCommands[nextCommand.cmd.token] = nextCommand.cmd;
                        this._log(`Sending command, "${nextCommand.cmd.name}" with priority "${nextCommand.priority === 1 ? 'NORMAL' : nextCommand.priority === 2 ? 'HIGH' : nextCommand.priority === 0 ? 'LOW' : 'unknown'}". ${this._sentCommands.length} command(s) in sentCommands, ${this.commandQueueLength} command(s) in command queues.`);
                        this._socket.executeCommand(nextCommand.cmd);
                    }
                }
            }
            else if (this._queueMode === QueueMode.SEQUENTIAL) {
                let nextCommand = this._fetchNextCommand();
                if (nextCommand) {
                    this._sentCommands[nextCommand.cmd.token] = nextCommand.cmd;
                    this._log(`Sending command, "${nextCommand.cmd.name}" with priority "${nextCommand.priority === 1 ? 'NORMAL' : nextCommand.priority === 2 ? 'HIGH' : nextCommand.priority === 0 ? 'LOW' : 'unknown'}". ${this._sentCommands.length} command(s) in sentCommands, ${this.commandQueueLength} command(s) in command queues.`);
                    this._socket.executeCommand(nextCommand.cmd);
                }
            }
        }
        else {
            if (this.commandQueueLength > 0) {
                this._log(`Can't process commands, socket not connected. ${this.commandQueueLength} commands left in commandsQueue, the first one being "${this._nextCommand ? this._nextCommand.cmd.name : 'null'}".`);
            }
        }
    }
}
exports.CasparCG = CasparCG;
//# sourceMappingURL=CasparCG.js.map